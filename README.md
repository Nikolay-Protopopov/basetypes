# Домашнее задание к занятию «Базы данных, их типы» - Протопопов Николай Андреевич


### Инструкция по выполнению домашнего задания

   1. Сделайте `fork` данного репозитория к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/git-hw или  https://github.com/имя-вашего-репозитория/7-1-ansible-hw).
   2. Выполните клонирование данного репозитория к себе на ПК с помощью команды `git clone`.
   3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
      - впишите вверху название занятия и вашу фамилию и имя
      - в каждом задании добавьте решение в требуемом виде (текст/код/скриншоты/ссылка)
      - для корректного добавления скриншотов воспользуйтесь [инструкцией "Как вставить скриншот в шаблон с решением](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md)
      - при оформлении используйте возможности языка разметки md (коротко об этом можно посмотреть в [инструкции  по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md))
   4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`);
   5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
   6. Любые вопросы по выполнению заданий спрашивайте в чате учебной группы и/или в разделе “Вопросы по заданию” в личном кабинете.
   
Желаем успехов в выполнении домашнего задания!
   
### Дополнительные материалы, которые могут быть полезны для выполнения задания

1. [Руководство по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637#Code)


---
#Комманды для работы с GIT
1. git clone https://github.com/Nikolay-Protopopov/homework-zabbix.git
2. cd homework-zabbix 
3. mkdir screenshots
4. git add README.md screenshots/ 
5. git commit -m "Добавлены скриншоты и обновлен README"
6. git remote set-url origin "https://мой токен@github.com/Nikolay-Protopopov/homework-zabbix.git"
7. git push origin main

### Задание 1. СУБД
Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.


Ответ: 
Основной выбор: Реляционная (SQL) СУБД. Например, PostgreSQL или Microsoft SQL Server.

Почему: Задача требует абсолютной целостности данных (ACID), жесткой структуры (схемы), сложных запросов с джойнами (объединениями) и агрегациями. Финансовые отчеты, бюджетные планы, статьи расходов — это классические табличные структуры с четкими связями. Эти СУБД идеально подходят для OLAP (аналитической обработки) и построения корпоративных хранилищ данных (Data Warehouse). Прогнозирование рисков часто делается на основе исторических данных, которые удобно хранить и агрегировать именно в SQL.
1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?
1.1. Хеширование стало занимать длительное время:* Скорее всего, речь идет о вычислении хешей для обеспечения целостности или паролей. Для ускорения можно использовать встроенные криптографические функции СУБД (например, pgcrypto в PostgreSQL) или вынести эту задачу на уровень приложения, используя специализированные библиотеки (API), такие как OpenSSL или libsodium, которые часто более оптимизированы для процессорных инструкций. Если хеширование — узкое место в бизнес-логике, стоит провести профилирование кода и, возможно, использовать аппаратное ускорение.

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.
Для лендингов: Документная NoSQL СУБД. Например, MongoDB или Couchbase.

Почему: Данные с форм захвата (лиды) могут быть разнообразными и меняться со временем (новые поля для разных акций). Документная модель позволяет гибко хранить информацию о лиде без жесткой схемы, что ускоряет разработку и изменение лендингов. Скорость записи и чтения для отдельных документов (лидов) высокая.

Для CRM: Реляционная (SQL) СУБД. Например, PostgreSQL.

Почему: Работа менеджеров — это классическая CRM: воронки продаж, этапы сделок, история взаимодействий, задачи, email-рассылки. Здесь критичны связи между сущностями (Клиент -> Сделка -> Встреча -> Документ), транзакционность, строгая структура и возможность строить сложные отчеты по эффективности
1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?
Оптимальный вариант для обеих задач — PostgreSQL. Почему:

Он поддерживает JSONB — бинарное хранение JSON-документов. Это дает гибкость NoSQL внутри реляционной СУБД. Данные с лендинга можно писать в поле типа JSONB, сохраняя всю произвольную структуру.

Одновременно вся основная CRM-логика строится на классических таблицах с соблюдением ACID.

Это упрощает архитектуру: данные не нужно синхронизировать между разными системами. Все находится в одном месте, что упрощает аналитику по лидам.

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.
Основной выбор: Графовая СУБД или Реляционная СУБД.

Почему графовая (Neo4j, ArangoDB): Если структура знаний действительно сложна и иерархична (например, нормативный документ -> раздел -> пункт -> ссылка на обучающий материал -> ссылка на ответственного), графовая СУБД позволит интуитивно моделировать и быстро обходить эти связи. Поиск всех связанных документов для определенной нормы будет очень эффективным.

Почему реляционная (PostgreSQL): Если структура больше похожа на классический справочник (разделы, документы, теги) с деревьями ограниченной вложенности, то можно использовать реляционную модель с таблицами и связями или даже иерархические структуры (CTE - Common Table Expressions). Это проще и понятнее для большинства разработчиков.

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?
Да, в большинстве случаев — да.

Если в компании уже выбран PostgreSQL для задач 1.1 и 1.2, то для базы знаний он тоже отлично подойдет. Иерархию можно организовать через таблицу documents с полем parent_id или через модель «Вложенные множества» (Nested Sets) для более быстрого чтения деревьев. Для связи документов между собой (перекрестные ссылки) создается отдельная таблица связей document_links.
1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.
Основной выбор: Графовая СУБД. Например, Neo4j или ArangoDB (поддерживает также документную модель).

Почему: Это классическая задача для графов. Сущности: точки (объекты, склады, офисы), дороги/пути (связи с атрибутами: расстояние, время, стоимость проезда), курьеры и материалы. Графовая СУБД создана для быстрого нахождения кратчайших/оптимальных путей (алгоритмы Дейкстры, A*) и работы со сложными связями. Позволяет легко моделировать и изменять логистическую сеть.
1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?
Лучше создать отдельную, но связанную систему.
Логистика работает с графом пространственных и временных связей.
Закупки работают с реляционной моделью данных: номенклатура материалов, поставщики, договоры, заявки, счета, складские остатки (лучше под PostgreSQL).

Реализация связки: Система закупок передает в систему логистики "задание" на доставку: что, откуда, куда, когда. Логистическая система на основе своей графовой БД строит оптимальный маршрут. Они общаются через API (REST, GraphQL). Это соответствует принципам микросервисной архитектуры, где каждый сервис использует наиболее подходящую для его задач БД.
1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

Приведите ответ в свободной форме.
Ответ: Технически — да, но архитектурно это будет компромисс с существенными недостатками.

Универсальный кандидат: PostgreSQL.

Аргументы "За":

Для задач 1.1 (финансы) и 1.2 (CRM) он идеален.

С помощью JSONB можно закрыть потребность в гибкости для лендингов (1.2).

Для базы знаний (1.3) можно использовать реляционные и иерархические структуры.

Для логистики (1.4) можно хранить графовые данные в таблицах (списки смежности), но это будет сильно менее эффективно, чем специализированная графовая СУБД. Алгоритмы поиска путей придется писать на стороне приложения, что сложно и медленно.

Аргументы "Против":

Производительность: Вы теряете в скорости и эффективности для специализированных задач (логистика — графы, аналитика Big Data — колоночные хранилища).

Сложность: Одна БД становится "единой точкой отказа" и "всеобщей свалкой". Масштабировать разные части системы под разную нагрузку становится крайне сложно.

Выбор инструмента под задачу: Современная архитектура строится на принципе «Use the best tool for the job». Насильственное использование одного инструмента для всех задач ведет к переусложнению и высоким издержкам поддержки.
### Задание 2. Транзакции
2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.
В основе — принцип ACID, особенно атомарность и согласованность. Предполагаем, что система включает как минимум две сущности: Счет пользователя (Accounts) и Журнал транзакций (Transactions).

Шаги успешной транзакции:

Начало транзакции (BEGIN TRANSACTION).

СУБД фиксирует точку начала и блокирует изменяемые данные (или использует механизм версионирования, например, как в PostgreSQL MVCC) для обеспечения изоляции.

Проверка данных и резервирование средств.

Проверяется валидность номера телефона и статус счета.

С системы платежного агента (или со счета пользователя в системе, если речь о внутреннем балансе) холдруется (резервируется) сумма пополнения. На этом этапе деньги списываются у плательщика, но еще не зачислены получателю. Запись об этом попадает в журнал транзакций со статусом pending.

Зачисление средств на целевой счет.

В таблице Accounts для строки с указанным номером телефона значение в поле balance увеличивается на сумму пополнения (UPDATE accounts SET balance = balance + <amount> WHERE phone = <phone_number>).

Фиксация операции в журнале.

В таблице Transactions создается окончательная запись с деталями операции (ID, timestamp, сумма, отправитель, получатель, тип операции "пополнение") и статусом completed. Связь между обновлением баланса и записью в журнале должна быть атомарной.

Подтверждение внешней платежной системе.

Платежному шлюзу или оператору связи отправляется подтверждение (чек), что операция успешно завершена на стороне получателя. Это важно для сверки и предотвращения споров.

Завершение транзакции (COMMIT).

Все изменения, сделанные на шагах 2-4 (обновление балансов, создание записей в журнале), окончательно фиксируются в базе данных как единое целое. Блокировки снимаются, результат операции становится видимым для других транзакций. Пользователь получает уведомление об успешном пополнении.

Если на любом из шагов 2-5 происходит ошибка (недостаточно средств, неверный номер, сбой связи с оператором), выполняется ROLLBACK (откат). Все промежуточные изменения (холд, изменение баланса) отменяются, система возвращается в состояние, предшествовавшее началу транзакции.
2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

Приведите ответ в свободной форме.
Автоплатёж добавляет новые сущности (расписание, правила) и этапы валидации. Транзакция пополнения вкладывается в более сложный управляющий процесс.

Действия при срабатывании автоплатежа:

Запуск по расписанию (Scheduler).

Отдельный сервис (планировщик, cron) в заданное время (например, ежедневно в 8:00) запускает процесс обработки всех активных автоплатежей, срок действия которых наступил.

Проверка условий срабатывания.

Для каждого автоплатежа система проверяет дополнительные условия перед инициированием платежной транзакции:

Условие баланса: Пополнять только если баланс абонента ниже порогового значения X?

Условие активности: Активна ли услуга у абонента?

Условие лимитов: Не превышен ли месячный/дневной лимит на автопополнения?

Если условия не выполнены — автоплатёж откладывается до следующего цикла проверки, транзакция не начинается. Пользователю может отправляться уведомление.

Инициация платежной транзакции.

Только если условия выполнены, система выполняет шаги, аналогичные ручному пополнению (2.1), но с особенностями:

В качестве источника средств указывается привязанная карта/кошелек пользователя.

Процесс может включать дополнительный шаг предавторизации карты (проверка ее активности и лимитов) через платежный шлюз.

Обработка результата и уведомления.

При успехе (COMMIT): В журнал транзакций добавляется пометка, что операция выполнена по автоплатежу. Пользователю отправляется уведомление о списании и пополнении. Обновляется дата следующего списания (например, на следующий месяц).

При неудаче (ошибка карты, недостаточно средств — ROLLBACK): Система:

Записывает неудачную попытку в историю автоплатежа.

Увеличивает счетчик неудачных попыток.

При превышении лимита неудач (например, 3 подряд) — деактивирует автоплатёж.

Отправляет пользователю уведомление о проблеме с просьбой обновить платежные данные.

Логирование и отчетность.

Все этапы работы планировщика автоплатежей (запуск, проверки, результаты) фиксируются в отдельном логе для аудита, мониторинга и отладки.

Ключевое отличие: Автоплатёж — это управляемый процесс (оркестратор), который на основе правил и состояния системы принимает решение: инициировать ли атомарную финансовую транзакцию. Сама же операция пополнения, если она запущена, должна оставаться такой же атомарной и ACID-ной, как и при ручном пополнении.
### Задание 3. SQL vs NoSQL
3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.
Жесткая схема данных (Schema) и гарантии целостности.

Что это: Обязательное предварительное определение структуры таблиц, типов данных, связей и ограничений (PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK).

Преимущество: Исключает попадание в базу мусорных или некорректных данных на уровне СУБД. Это критически важно для финансовых, бухгалтерских, государственных систем, где качество и согласованность данных — приоритет №1. Любое нарушение правил приводит к ошибке, что предотвращает порчу данных.

Полная поддержка ACID-транзакций.

Что это: Атомарность, Согласованность, Изоляция, Долговечность как единый, гарантированный стандарт для операций, затрагивающих несколько строк/таблиц.

Преимущество: Позволяет строить сложную бизнес-логику, где успех операции зависит от одновременного изменения нескольких сущностей. Классический пример — перевод денег со счета на счет: списание с одного и зачисление на другой должно быть единой неделимой операцией. В NoSQL такие гарантии либо отсутствуют, либо их реализация сложна и нестандартна.

Мощный, стандартизированный язык запросов (SQL) и сложные JOIN.

Что это: Единый декларативный язык для работы с данными, основанный на реляционной алгебре. Возможность легко соединять (JOIN) десятки таблиц по различным условиям.

Преимущество: Гибкость при извлечении данных. Аналитик или разработчик может написать один (пусть и сложный) запрос, чтобы получить сводный отчет из нормализованных данных. В NoSQL подобные выборки часто требуют множественных обращений к базе и сложной агрегации на стороне приложения, что менее эффективно и более трудоемко.

Зрелость, стабильность и экосистема.

Что это: Системам класса PostgreSQL, Oracle, MySQL — десятки лет. Они прошли испытание временем в самых ответственных областях (банки, телеком).

Преимущество: Предсказуемость, надежность, подробная документация, обширный рынок специалистов, богатый набор инструментов для администрирования, мониторинга, бэкапа и миграции. Для NoSQL, особенно новых систем, эти аспекты часто являются "растущей болью".

Единая точка истины и нормализация.

Что это: Принцип, согласно которому каждый факт хранится в единственном месте, что устраняет избыточность и возможные противоречия.

Преимущество: Упрощает поддержку и обновление данных. Например, адрес клиента хранится в одной таблице clients, а все его заказы в таблице orders содержат лишь ссылку (client_id). При смене адреса его нужно обновить только в одном месте. В документных NoSQL-базах данные часто денормализованы и дублируются, что может привести к рассинхронизации.
3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

Приведите ответ в свободной форме.
NewSQL (CockroachDB, Google Spanner, YugabyteDB) — это попытка взять лучшее от двух миров: горизонтальная масштабируемость и отказоустойчивость NoSQL + SQL-интерфейс и сильные гарантии ACID традиционных СУБД.

Преимущества перед классическим SQL (PostgreSQL, MySQL):

Горизонтальное масштабирование (масштабирование "вширь").

NewSQL: Легко добавляйте новые сервера (ноды) в кластер для распределения нагрузки и данных. Прозрачно для приложения. Идеально для растущих, глобальных сервисов.

Классический SQL: Масштабирование в основном вертикальное (более мощный сервер — Scale-Up), что имеет физические и финансовые ограничения. Шардинг (горизонтальное деление данных) — сложная, ручная операция, ломающая многие преимущества SQL (например, JOIN между шардами).

Высокая доступность и отказоустойчивость "из коробки".

NewSQL: Данные автоматически реплицируются между нодами. При падении одной ноды кластер продолжает работать без потерь и с минимальной деградацией. Восстановление происходит автоматически.

Классический SQL: Требует сложной настройки репликации (master-slave, кластеризация), часто с ручным вмешательством при сбоях.

Преимущества перед NoSQL:

Сильные транзакционные гарантии (ACID) в распределенной среде.

NewSQL: Обеспечивает распределенные ACID-транзакции (часто с использованием протокола Raft или Paxos). Это позволяет безопасно изменять данные, расположенные на разных серверах, как единое целое.

NoSQL: Часто жертвует строгой консистентностью (C в ACID) в пользу доступности и устойчивости к разделению (CAP-теорема). Модель согласованности — eventual consistency (конечная согласованность), что неприемлемо для многих финансовых операций.

Полноценный SQL и реляционная модель.

NewSQL: Поддерживает JOIN, вторичные индексы, сложные запросы, внешние ключи — все то, к чему привыкли разработчики.

NoSQL: Использует свои специфические языки запросов (часто более ограниченные) или требует денормализации данных под конкретные сценарии доступа.

Итог: NewSQL — это "бесплатный обед" для архитекторов в мире распределенных систем. Они решают главную дилемму: "Мне нужны гарантии ACID и SQL, но мои данные и нагрузка слишком велики для одного сервера". Это делает их идеальным выбором для новых, глобальных, сильно нагруженных приложений, где целостность данных не менее важна, чем масштабируемость (например, финтех, крупные SaaS-платформы, игровые сервисы).
### Задание 4. Кластеры
Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.

На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

Приведите ответ в свободной форме.
Ключевой критерий выбора: Характер вычислений и модель доступа к данным
Основной критерий выбора — разделение между OLAP и OLTP:

OLAP (аналитические запросы) — если нужно анализировать исторические данные, строить отчёты, делать агрегации (суммы, средние, группировки) по огромным массивам данных

OLTP (операционные транзакции) — если нужно обрабатывать множество коротких операций в реальном времени (вставка, обновление, удаление)

При формулировке "большое количество вычислений при работе с огромным количеством данных" с высокой вероятностью речь идёт об OLAP-сценарии.

Оптимальная модель распределённых вычислений: MPP (Massively Parallel Processing)
Почему MPP лучше всего подходит для 1000 машин:

Архитектура Shared-Nothing

Каждая машина независима, имеет свои процессор, память и диски

Нет единых точек отказа (shared disk) или узких мест (shared memory)

Позволяет достичь почти линейного масштабирования

Параллельная обработка запросов

Запрос разбивается на множество подзапросов

Каждая машина обрабатывает свою порцию данных

Все 1000 машин работают одновременно над одной задачей

Результаты агрегируются координатором

Оптимизация для аналитики

Данные распределяются партицированием (часто по диапазонам или хешу)

Поддерживается колоночное хранение для ускорения агрегаций

Минимизируются перемещения данных между узлами

Конкретные типы систем для MPP-архитектуры
1. Специализированные колоночные MPP-СУБД (лучший выбор для чистой аналитики)
Примеры: ClickHouse, Vertica, Greenplum, Amazon Redshift

Почему подходят:

Колоночное хранение — при запросе SELECT SUM(revenue) FROM sales читается только колонка revenue, а не все строки

Эффективное сжатие — однотипные данные в колонках сжимаются в 5-10 раз лучше

Векторизованные вычисления — обработка блоками данных, а не построчно

Идеально для агрегаций — GROUP BY, JOIN, оконные функции работают оптимально

ClickHouse — особенно выделяется:

Производительность на raw-железе без зависимостей

Поддержка реального времени (запросы за секунды на триллионах строк)

Отличная горизонтальная масштабируемость

2. Вычислительные фреймворки + хранилище (для сложных ETL/пайплайнов)
Примеры: Apache Spark + Parquet/Delta Lake, Presto/Trino, Dask

Почему подходят:

Гибкость программирования — не только SQL, но и код на Python/Scala/R

Расширенные возможности — ML, графовые алгоритмы, стриминг

Отказоустойчивость — автоматическое восстановление при падении узлов

Экосистема — интеграция с Kafka, Hadoop, облачными хранилищами

Критерии выбора конкретного решения
Тип запросов:

Только SQL-аналитика → ClickHouse/Greenplum

Сложные ETL-пайплайны, ML → Apache Spark

Ad-hoc аналитика разных форматов → Presto/Trino

Требования к задержке:

Интерактивные запросы (<1-10 сек) → колоночные СУБД

Пакетная обработка (минуты/часы) → фреймворки

Стоимость и управление:

Open-source самоподдержка → ClickHouse, Spark

Коммерческая поддержка → Vertica, Greenplum

Облачный managed-сервис → Redshift, BigQuery, Snowflake

Модель данных:

Строгая схема → классические MPP-СУБД

Полуструктурированные данные, схемы на чтение → Presto/Spark

Рекомендация для 1000 машин
Для большинства сценариев: ClickHouse в MPP-режиме

Архитектура:

text
[Клиент] → [Лоад-балансер/ZooKeeper] → [Координаторы (3-5 узлов)] → [Шарды (1000 машин, с репликацией 2-3x)]
Преимущества:

Максимальная производительность на аналитических запросах

Простота эксплуатации (отсутствие зависимостей вроде HDFS)

Эффективное использование ресурсов всех 1000 машин

Поддержка реального времени

Альтернатива: Если нужна экосистема Hadoop/HDFS или сложные ML-задачи → Apache Spark + HDFS/Alluxio

Почему не подходят другие модели
Shared Memory (SMP) — не масштабируется до 1000 машин

Shared Disk — узкое место на общем хранилище

Классические реляционные СУБД — неэффективны для аналитики на больших данных

NoSQL-системы — не оптимизированы для сложных аналитических запросов

Вывод: Для 1000 машин и аналитических вычислений над большими данными оптимальна MPP-архитектура со специализированной колоночной СУБД (ClickHouse) или вычислительным фреймворком (Spark) в зависимости от конкретных требований к типам вычислений и гибкости.